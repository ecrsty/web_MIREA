<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Source Analytics</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container mt-5">
    <h1 id="sourceName">Source Analytics</h1>
    
    <!-- Аналитика -->
    <div class="mb-5">
      <h3>Publishing Trends</h3>
      <canvas id="timeChart" width="400" height="200"></canvas>
    </div>

    <div class="mb-5">
      <h3>Tags Distribution</h3>
      <canvas id="tagsChart" width="400" height="200"></canvas>
    </div>

    <div class="mb-5">
      <h3>Updated vs Not Updated</h3>
      <canvas id="updatesChart" width="400" height="200"></canvas>
    </div>

    <!-- Список статей -->
    <h3>Articles</h3>
    <ul id="articlesList" class="list-group"></ul>
  </div>

  <script>
    // Получаем параметр source из URL
    const params = new URLSearchParams(window.location.search);
    const source = params.get('source') || 'Unknown';

    // Устанавливаем название источника
    document.getElementById('sourceName').textContent = `Source: ${source}`;

    // Функция для загрузки данных по источнику
    async function fetchSourceData() {
      try {
        // Запрос на сервер для получения всех статей
        const response = await fetch('http://localhost:3000/articles');
        const articles = await response.json();

        // Фильтруем статьи по источнику
        const filteredArticles = articles.filter(article => article.source === source);

        // Список статей
        const articlesList = document.getElementById('articlesList');
        filteredArticles.forEach(article => {
          const listItem = document.createElement('li');
          listItem.className = 'list-group-item';
          listItem.innerHTML = `<a href="article.html?id=${article.id}">${article.header}</a>`;
          articlesList.appendChild(listItem);
        });

        // Динамическая аналитика
        generateCharts(filteredArticles);
      } catch (error) {
        console.error('Ошибка при загрузке данных:', error);
      }
    }

    // Функция для генерации графиков
    function generateCharts(articles) {
      // Данные для графиков
      const publicationDates = articles.map(article => new Date(article.publish_date).toLocaleDateString());
      const tags = articles.flatMap(article => article.category.split(', '));
      const updatedCounts = [
        articles.filter(article => article.update_date).length,
        articles.filter(article => !article.update_date).length
      ];

      // График публикаций
      const ctxTime = document.getElementById('timeChart').getContext('2d');
      new Chart(ctxTime, {
        type: 'line',
        data: {
          labels: [...new Set(publicationDates)], // Уникальные даты
          datasets: [{
            label: 'Number of Articles',
            data: publicationDates.reduce((acc, date) => {
              acc[date] = (acc[date] || 0) + 1;
              return acc;
            }, {}),
            borderColor: 'blue',
            fill: false
          }]
        }
      });

      // Круговая диаграмма по тегам
      const ctxTags = document.getElementById('tagsChart').getContext('2d');
      const tagCounts = tags.reduce((acc, tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
      }, {});
      new Chart(ctxTags, {
        type: 'pie',
        data: {
          labels: Object.keys(tagCounts),
          datasets: [{
            data: Object.values(tagCounts),
            backgroundColor: ['red', 'green', 'blue', 'orange', 'purple']
          }]
        }
      });

      // Круговая диаграмма: Updated vs Not Updated
      const ctxUpdates = document.getElementById('updatesChart').getContext('2d');
      new Chart(ctxUpdates, {
        type: 'doughnut',
        data: {
          labels: ['Updated', 'Not Updated'],
          datasets: [{
            data: updatedCounts,
            backgroundColor: ['green', 'red']
          }]
        }
      });
    }

    // Запускаем загрузку данных
    fetchSourceData();
  </script>
</body>
</html>
